<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>RealmSwiftでまだ存在しないオブジェクトだけを追加する | thara.dev</title>
  <link rel="stylesheet" type="text/css" href="https://thara.dev/css/neat.css">
  <link rel="stylesheet" type="text/css" href="https://thara.dev/css/custom.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="thara">
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@zetta1985" />
  <meta name="twitter:title" content="RealmSwiftでまだ存在しないオブジェクトだけを追加する | thara.dev" />
  <meta name="Hatena::Bookmark" content="nocomment" />
  <link rel="author" href="http://www.hatena.ne.jp/zetta1985/" />
</head>
<body>
  <header>
    <h1>RealmSwiftでまだ存在しないオブジェクトだけを追加する</h1>
    <time>2018-10-22</time>
  </header>
  <div role="main">
    <article>
    <p>RDBを使用したアプリケーションでよくあるパターンなんだけど、Realmではあまり例がなさそうだったので。</p>
<p>以下のモデルを例に取り上げる。</p>
<pre><code class="language-swift">class SampleObject: Object {
    // 略
    override static func primaryKey() -&gt; String? {
        return &quot;identifier&quot;
    }
}

// すでに保存されている/まだ保存されていないモデルが混在
let objects: [SampleObject] = ....
</code></pre>
<h2>問題</h2>
<ul>
<li>すでに保存されているRealmモデルとまだ保存されていないRealmモデルが混在するArrayがある</li>
<li>そのArrayのうち、まだ保存されていないRealmモデルだけをRealmに新規追加したい</li>
<li>すでに保存されているRealmモデルのプロパティを更新したくない</li>
<li>少ないデータアクセス回数で抑えたい</li>
</ul>
<p><code>Realm#add</code> には複数オブジェクトを渡すことができるが、引数<code>update</code>をtrueにするとobjects内の「すでに保存されているRealmモデル」が更新されてしまい、falseにするとidentifierの値が重複するためエラーが発生する。</p>
<pre><code>realm.add(objects, update: true)  // すでに保存されているRealmモデルが更新される
realm.add(objects, update: false) // identifierの値が重複するためエラー
</code></pre>
<h2>解決方法</h2>
<p>ポイントは「すでに保存されているRealmモデルのキー」がわかれば「まだ保存されていないRealmモデル」が分かる、ということ。</p>
<pre><code class="language-swift">// すべてのprimaryKeyのArray
let keys = objects.map { $0.identifier }

// すでに保存されているRealmモデルを取得して、そのprimaryKeyのSetを得る
let storedKeys = Set(
    realm.objects(SampleObject.self)
      .filter(&quot;identifier IN %@&quot;, keys).map { $0.identifier })

// すでに保存されているRealmモデルのprimaryKeyに一致しないオブジェクトを選択する
let newObjects = objects.filter { !storedKeys.contains($0.identifier) }

if newObjects.count != 0 {
    try realm.write {
        // newObjectsはまだ保存されていないRealmモデルのみなので update: false
        realm.add(newObjects, update: false)
    }
}
</code></pre>
<p>効率的にデータアクセスするために以下の2点の工夫を入れている。</p>
<ul>
<li>「すでに保存されているRealmモデルのキー」を一度のデータアクセスで取得する</li>
<li>「すでに保存されているRealmモデルのキー」を <code>Set</code>にすることで<code>contains</code>の計算量をO(1)にする</li>
</ul>
<p>「すでに保存されているRealmモデル」の数が多い場合は、より効果的になる。</p>

    </article>
  </div>
  <footer>
  <small>
    <a href="https://thara.dev">Home</a>
    | <a href="https://github.com/thara/thara.github.io">GitHub</a>
    | <a href="https://thara.dev/about">About</a>
    | <a href="https://thara.dev/resume-ja">Resume(ja)</a>
    | &copy; 2023 thara
  </small>
</footer>
</body>
</html>
