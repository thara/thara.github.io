<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="thara">
  <title>中規模Djangoアプリケーションのモジュール構成 | thara.dev</title>
  <link rel="stylesheet" href="https://thara.dev/css/main.css">
</head>
<body>
  <header>
    <h1>
      <a href="https://thara.dev">thara.dev</a>
    </h1>
  </header>
  <div role="main">
    <div>
      <h1>中規模Djangoアプリケーションのモジュール構成</h1>
      <span>2016-12-09</span>
    </div>
    <article>
    <p>DjangoやRuby on Railsといったフルスタックフレームワークは、シンプルなCRUDアプリケーションを素早く構築することができるが、複雑なアプリケーションの設計をどうすればよいかという問題にはいつも悩まされる。</p>
<p>どのようなプロジェクトによるかはケースバイケースだが、自分の中でおおよそ固まってきたので、それをまとめてみる。</p>
<p>Djangoの場合、フレームワークが必要とするモジュールはsettings.pyとmodels.pyぐらいなので、各Djangoアプリケーション内では割と自由にモジュールを定義できる。</p>
<p>自分は以下のような自作モジュールを配置するようにしている。</p>
<ul>
<li>commands</li>
<li>query</li>
<li>services</li>
<li>utils</li>
</ul>
<h3>commands</h3>
<p>まずは、command。このcommandはGoFのCommandパターンのことではなく、Command-Query Responsibility SegregationのCommand。<br />
つまり、更新系のオペレーションのこと。
このモジュールには、更新用の関数とその関数用の引数/戻り値（入力/出力）用ののDTOが含まれ、viewsから直接使用される。
このモジュールの更新用関数は、DBのトランザクション境界とおおよそ一致する。</p>
<p>大体以下のような感じ。</p>
<pre><code class="language-python">from collections import namedtuple

UserProfileUpdateCommand = namedtuple(
    &quot;UserUpdateCommand&quot;, &quot;user_id user_name email_address&quot;)
class UserProfileUpdateResult(namedtuple(
    &quot;UserProfileUpdateResult&quot;, &quot;success errors&quot;)):
    def to_dict(self):
        return {&quot;success&quot;: self.success, &quot;errors&quot;: self.errors}


def _validate_command(command: UserProfileUpdateCommand):
    &quot;&quot;&quot; commandに指定された値のプロパティ検証 &quot;&quot;&quot;

def update_user_profile(command: UserProfileUpdateCommand):
    &quot;&quot;&quot; 更新系処理 &quot;&quot;&quot;
    errors = _validate_command(command)
    if errors:
        return UserProfileUpdateResult(success=False, errors=errors)

    with transaction.atomic():
        user_profile = UserProfile.objects.get(command.user_id)
        user_profile.user_name = command.user_name
        user_profile.email_address = command.email_address
        user_profile.save(
            update_fields=['user_name', 'email_address'])

    return UserProfileUpdateResult(success=True, errors=[])    
</code></pre>
<p><code>_validate_command</code> は、上の例のようにシンプルな更新であれば<code>UserProfile</code>のメソッドとして提供してもよいかもしれない。<br />
が、modelを更新する機能が複数ある場合は検証処理もそれによって異なることがあるので、そのような検証処理はcommandに定義した方がいいだろう。<br />
また、commandでmodelの<code>save</code>メソッドを直接呼ぶのも良いが、複数の機能から同じような更新処理を実行するのであれば、modelにメソッドを実装するのも悪くない。</p>
<p>これらの関数/クラス はViewから以下のように使われる。（RESTｆrameworkを使用を前提としている）</p>
<pre><code class="language-python">
class UserProfileView(APIView):

    def post(self, request):
        s = UserProfileUpdateSerializer(data=request.data)
        s.is_valid(raise_exception=True)
        command = UserProfileUpdateCommand(
            user_id=serializer.validated_data['user_id'],
            user_name=serializer.validated_data['user_name'],
            email_address=serializer.validated_data['email_address'])
        result = update_user_profile(command)
        return Response(result.to_dict(), status=status.HTTP_200_OK)

</code></pre>
<h3>query</h3>
<p>queryは、commandと対照的に、viewsから使用される参照系の関数を定義する。</p>
<pre><code>def get_user_profile(user_id):
    return UserProfile.objects.using('read_replica').get(user_id)
</code></pre>
<p>この例だとあまり利点は見えないが、DBリードレプリカを参照したり、キャッシュからデータを取ってくるなど、パフォーマンス優先の実装を配置するのに最適。</p>
<h2>services / utils</h2>
<p>このserviceとは、レイヤードアーキテクチャのサービス層ともDDDのドメインサービスとも関係がない。
services.pyには、viewsからは直接使用されないが、同じDjangoアプリケーション内のcommandsやquery、または異なるDjangoアプリケーションから使用される関数やクラスを定義する。</p>
<p>一方のutilsは、あらゆるアプリケーションから使用される可能性があるユーティリティ関数を定義する。
こちらは極力、Djangoなどのフレームワークに依存しないことが望ましい。</p>
<h2>Djangoアプリケーションの構成</h2>
<p>ここまで挙げた、 commands, query, services, utilsを、機能を表すパッケージごとに定義する。</p>
<p>以下は一例。</p>
<p>より実際のファイル構成に近くなるよう、フレームワークの使用にあたって必要になるであろうファイルも配置した。</p>
<p>models.py, views.py, urls.pyはそれぞれDjangoのDBモデル, View, URLディスパッチ設定。serializers.pyはDjango RESTframework用のJSONシリアライズ設定。</p>
<pre><code>sns_sample
├── friend
│   ├── request
│   │   ├── commands.py
│   │   ├── query.py
│   │   ├── serializers.py
│   │   └── services.py
│   ├── commands.py
│   ├── models.py
│   ├── query.py
│   ├── serializers.py
│   ├── serivces.py
│   ├── urls.py
│   └── views.py
└── user
    ├── login
    │   ├── commands.py
    │   ├── serializers.py
    │   └── services.py
    ├── signup
    │   ├── commands.py
    │   ├── serializers.py
    │   └── utils.py
    ├── models.py
    ├── serializers.py
    ├── urls.py
    └── views.py
</code></pre>
<p>だいたいこんな感じ。
それほど複雑になるわけでもなく、かといって不足もないようなちょうどよい塩梅だと思う。もちろん、プロジェクトの規模にもよるのだが、中規模であれば、これぐらいで良いだろう。</p>
<p>実際のモジュール配置場所を決定するために一番考えなければいけないことは、モジュール構成を変更するのはかなりリスキーである、ということを認識すること。</p>
<p>バージョン管理システムによるソースコードのバージョン管理もファイルの配置場所を変えるとうまくいかないことが多いため、今までのソースコードの変更履歴を追うのがめんどくさくなる。</p>
<p>よりシンプルでわかりやすい構成にしておくことを心掛けたい。</p>

    </article>
  </div>
  <footer>
  <small>
    <a href="https://thara.dev">Home</a>
    | <a href="https://github.com/thara/thara.github.io">GitHub</a>
    | <a href="https://thara.dev/about">About</a>
    | <a href="https://thara.dev/resume-ja">Resume(ja)</a>
    | &copy; 2022 thara
  </small>
</footer>
</body>
</html>

