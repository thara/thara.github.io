<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Tomochika Hara">
  <title>Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない - thara.dev</title>
  <link rel="stylesheet" type="text/css" href="https://thara.dev/css/neat.css">
  <link rel="stylesheet" type="text/css" href="https://thara.dev/css/custom.css">
  <meta name="og:title" content="Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない - thara.dev" />
  <meta name="og:type" content="article" />
  <meta name="og:site_name" content="thara.dev" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@zetta1985" />
  <meta name="twitter:title" content="Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない - thara.dev" />
  <meta name="Hatena::Bookmark" content="nocomment" />
  <link rel="author" href="http://www.hatena.ne.jp/zetta1985/" /></head>
<body>
  <header>
    <h1>Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない</h1>
    <ul>
      <li>published: <time>2019-05-22</time></li>
    </ul>
  </header>
  <div role="main">
    <article>
<p>Kotlin Testでテスト書いてて、ブロックスコープ作ろうとして
<code>{}</code> で文を囲ったが、この <code>{}</code> はlambda
リテラルにパースされるようで、中の文が実行されない。 Swiftでもあったなー
<code>do {...}</code>
とかやったなーとか思いつつ、Kotlinでどうやるか色々探していたが、どうやらキーワードつけるだけでは無理っぽい。</p>
<p><code>{...}()</code>
と書いて、lambdaを即時実行させる例を見かけたので、それを使って以下のように書いたが、
今度はコンパイルが通らない。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Foo&quot;</span><span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Bar&quot;</span><span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span></code></pre></div>
<blockquote>
<p>Too many arguments for public abstract operator fun invoke()</p>
</blockquote>
<p>というエラーメッセージ。</p>
<p>ひとまず、その場はテスト対象のオブジェクトに対してScope Functionの
<code>run</code> を使うことで、目的は達成できたのだが、
先のエラーメッセージの意味がわからない。引数、渡してないし。。。</p>
<p>ということをつぶやいていたら <a
href="https://twitter.com/kokuyouwind">@kokuyouwind</a>
から「パース狂ってるのでは」「2個目のlambdaが1個目の呼び出しの引数としてパースされてそう」という指摘をもらったので、その線で調べてみたらドンピシャのissueがあった。</p>
<p><a href="https://youtrack.jetbrains.com/issue/KT-17884">Lambda
literal on the next line of a function call is parsed as an argument
("Too many arguments" error) : KT-17884</a></p>
<p>さらに同氏より 「<code>()</code>
だけは多分valid。件のエラーメッセージは型検査レベルのエラーなので、文法エラーではないっぽい」と言われた。</p>
<h2
id="2つ目のが構文エラーにならないのはなぜなのか">2つ目の()が構文エラーにならないのはなぜなのか</h2>
<p>手元で確認したところによると <code>()</code>
だけ書いてもコンパイルエラーになる。
よくわからんなー、と思って、今この文章を書いていたら、理由が思い当たった。</p>
<p>2個目の <code>()</code> は、
1個目のlambdaの戻り値がclosureだったときの呼び出し用の <code>()</code>
としてパースされているのではないか。
構文解析の段階ではvalidであり、まだ型検査中のなので、1個目のlambdaの戻り値が呼び出し可能か判定できていない。
そのため、先に
<code>Too many arguments ...</code>のエラーとなった、ということなのだろう。</p>
<p>検証するために、 まず <code>Too many arguments...</code>
をパスさせるために、以下のように1個目のlambdaが引数に関数を受け取るようにした。</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> p<span class="op">:</span> <span class="op">()</span> <span class="op">-&gt;</span> <span class="kw">Unit</span> <span class="op">-&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Foo&quot;</span><span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    p<span class="op">()</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Bar&quot;</span><span class="op">)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ()  ... ひとまずコンパイルを通すためにコメントアウト</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">// 以下のように出力される</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Foo</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Bar</span></span></code></pre></div>
<p>上記のコメントアウトを取ると、</p>
<blockquote>
<p>Expression .... of Type 'Unit' cannot be invoked as a function. The
function <code>invoke()</code> is not found</p>
</blockquote>
<p>という想定通りのエラーが出た。このコンパイルエラーを通すには、1個目のlambdaが関数を返さなければならない。</p>
<p>ここでは、渡された p をそのまま返してみよう。</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> p<span class="op">:</span> <span class="op">()</span> <span class="op">-&gt;</span> <span class="kw">Unit</span> <span class="op">-&gt;</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Foo&quot;</span><span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    p<span class="op">()</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    p</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Bar&quot;</span><span class="op">)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 以下のように出力される</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Foo</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Bar</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Bar</span></span></code></pre></div>
<p>「1個目のlambdaの戻り値がclosureだったときの呼び出し用の
<code>()</code>
としてパースされている」という予想は、どうやらあっていたようだ。</p>
<h2
id="2つのlambdaを即時実行させるには">2つのlambdaを即時実行させるには</h2>
<p>最初の問題にもどって2つのlambdaを即時実行させるには、1個目のlambdaの呼び出しと2個目のlamdbaの定義が別れていることをコンパイラに伝えればよいので、セミコロンで区切れば良い。</p>
<pre><code>    { 
        println(&quot;Foo&quot;)
    }();
    
    {
        println(&quot;Bar&quot;)
    }()</code></pre>
<p>普段セミコロンを使わずにコードを書いているので、違和感しかない・・・</p>
<p>パーサが修正されることは期待できないので、その場その場でScope
FunctionなどのKotlinらしい解決方法を見つけたほうが良さそう。</p>
    </article>
  </div>
<footer>
  <small>
    <a href="https://thara.dev">Home</a>
    | <a href="https://github.com/thara/thara.github.io">GitHub</a>
    | <a href="https://thara.dev/about.html">About</a>
    | &copy; 2024 Tomochika Hara
  </small></footer>
</body>
</html>
