<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="thara">
  <meta name="Hatena::Bookmark" content="nocomment" />
  <link rel="stylesheet" href="https://thara.dev/css/main.css">
  <link rel="author" href="http://www.hatena.ne.jp/zetta1985/" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@zetta1985" />
  <meta name="twitter:title" content="Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない | thara.dev" />
  <title>Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない | thara.dev</title>
</head>
<body>
  <header>
    <h1>
      <a href="https://thara.dev">thara.dev</a>
    </h1>
  </header>
  <div role="main">
    <div>
      <h1>Kotlinでは関数呼び出しの次のlambdaリテラルがパースできない</h1>
      <span>2019-05-22</span>
    </div>
    <article>
    <p>Kotlin Testでテスト書いてて、ブロックスコープ作ろうとして <code>{}</code> で文を囲ったが、この <code>{}</code> はlambda リテラルにパースされるようで、中の文が実行されない。
Swiftでもあったなー <code>do {...}</code> とかやったなーとか思いつつ、Kotlinでどうやるか色々探していたが、どうやらキーワードつけるだけでは無理っぽい。</p>
<p><code>{...}()</code> と書いて、lambdaを即時実行させる例を見かけたので、それを使って以下のように書いたが、 今度はコンパイルが通らない。</p>
<pre><code class="language-kotlin">{
        println(&quot;Foo&quot;)
}()

{
        println(&quot;Bar&quot;)
}()
</code></pre>
<blockquote>
<p>Too many arguments for public abstract operator fun invoke()</p>
</blockquote>
<p>というエラーメッセージ。</p>
<p>ひとまず、その場はテスト対象のオブジェクトに対してScope Functionの <code>run</code> を使うことで、目的は達成できたのだが、
先のエラーメッセージの意味がわからない。引数、渡してないし。。。</p>
<p>ということをつぶやいていたら <a href="https://twitter.com/kokuyouwind">@kokuyouwind</a> から「パース狂ってるのでは」「2個目のlambdaが1個目の呼び出しの引数としてパースされてそう」という指摘をもらったので、その線で調べてみたらドンピシャのissueがあった。</p>
<p><a href="https://youtrack.jetbrains.com/issue/KT-17884">Lambda literal on the next line of a function call is parsed as an argument (&quot;Too many arguments&quot; error) : KT-17884</a></p>
<p>さらに同氏より 「<code>()</code> だけは多分valid。件のエラーメッセージは型検査レベルのエラーなので、文法エラーではないっぽい」と言われた。</p>
<h2>2つ目の()が構文エラーにならないのはなぜなのか</h2>
<p>手元で確認したところによると <code>()</code> だけ書いてもコンパイルエラーになる。
よくわからんなー、と思って、今この文章を書いていたら、理由が思い当たった。</p>
<p>2個目の <code>()</code> は、 1個目のlambdaの戻り値がclosureだったときの呼び出し用の <code>()</code> としてパースされているのではないか。
構文解析の段階ではvalidであり、まだ型検査中のなので、1個目のlambdaの戻り値が呼び出し可能か判定できていない。
そのため、先に <code>Too many arguments ...</code>のエラーとなった、ということなのだろう。</p>
<p>検証するために、 まず <code>Too many arguments...</code> をパスさせるために、以下のように1個目のlambdaが引数に関数を受け取るようにした。</p>
<pre><code class="language-kotlin">{ p: () -&gt; Unit -&gt;
    println(&quot;Foo&quot;)
    p()
}()

{
    println(&quot;Bar&quot;)
} // ()  ... ひとまずコンパイルを通すためにコメントアウト
    
// 以下のように出力される
// Foo
// Bar
</code></pre>
<p>上記のコメントアウトを取ると、</p>
<blockquote>
<p>Expression .... of Type 'Unit' cannot be invoked as a function. The function <code>invoke()</code> is not found</p>
</blockquote>
<p>という想定通りのエラーが出た。このコンパイルエラーを通すには、1個目のlambdaが関数を返さなければならない。</p>
<p>ここでは、渡された p をそのまま返してみよう。</p>
<pre><code class="language-kotlin">{ p: () -&gt; Unit -&gt; 
    println(&quot;Foo&quot;)
    p()
    p
}()

{
    println(&quot;Bar&quot;)
}()

// 以下のように出力される
// Foo
// Bar
// Bar
</code></pre>
<p>「1個目のlambdaの戻り値がclosureだったときの呼び出し用の <code>()</code> としてパースされている」という予想は、どうやらあっていたようだ。</p>
<h2>2つのlambdaを即時実行させるには</h2>
<p>最初の問題にもどって2つのlambdaを即時実行させるには、1個目のlambdaの呼び出しと2個目のlamdbaの定義が別れていることをコンパイラに伝えればよいので、セミコロンで区切れば良い。</p>
<pre><code>    { 
        println(&quot;Foo&quot;)
    }();
    
    {
        println(&quot;Bar&quot;)
    }()
</code></pre>
<p>普段セミコロンを使わずにコードを書いているので、違和感しかない・・・</p>
<p>パーサが修正されることは期待できないので、その場その場でScope FunctionなどのKotlinらしい解決方法を見つけたほうが良さそう。</p>

    </article>
  </div>
  <footer>
  <small>
    <a href="https://thara.dev">Home</a>
    | <a href="https://github.com/thara/thara.github.io">GitHub</a>
    | <a href="https://thara.dev/about">About</a>
    | <a href="https://thara.dev/resume-ja">Resume(ja)</a>
    | &copy; 2023 thara
  </small>
</footer>
</body>
</html>

